"""
This type stub file was generated by pyright.
"""

import asyncio
import contextlib
import socket
import unittest
from abc import ABC, abstractmethod
from types import TracebackType
from typing import Any, Callable, Iterator, Optional, TYPE_CHECKING, Type, Union
from unittest import mock
from yarl import URL
from aiohttp.client import ClientResponse, _RequestContextManager, _WSRequestContextManager
from . import ClientSession
from .abc import AbstractCookieJar
from .client_reqrep import ClientResponse
from .client_ws import ClientWebSocketResponse
from .http import HttpVersion
from .web import Application, BaseRunner, Server, ServerRunner
from .web_protocol import _RequestHandler
from ssl import SSLContext

"""Utilities shared by tests."""
if TYPE_CHECKING:
    ...
else:
    ...
def get_unused_port_socket(host: str) -> socket.socket:
    ...

def get_port_socket(host: str, port: int) -> socket.socket:
    ...

def unused_port() -> int:
    """Return a port that is unused on the current host."""
    ...

class BaseTestServer(ABC):
    __test__ = ...
    def __init__(self, *, scheme: Union[str, object] = ..., loop: Optional[asyncio.AbstractEventLoop] = ..., host: str = ..., port: Optional[int] = ..., skip_url_asserts: bool = ..., **kwargs: Any) -> None:
        self.runner = ...
        self.host = ...
        self.port = ...
        self.scheme = ...
        self.skip_url_asserts = ...
    
    async def start_server(self, loop: Optional[asyncio.AbstractEventLoop] = ..., **kwargs: Any) -> None:
        self.runner = ...
        self.port = ...
    
    @abstractmethod
    async def _make_runner(self, **kwargs: Any) -> BaseRunner:
        ...
    
    def make_url(self, path: str) -> URL:
        ...
    
    @property
    def started(self) -> bool:
        ...
    
    @property
    def closed(self) -> bool:
        ...
    
    @property
    def handler(self) -> Server:
        ...
    
    async def close(self) -> None:
        """Close all fixtures created by the test client.

        After that point, the TestClient is no longer usable.

        This is an idempotent function: running close multiple times
        will not have any additional effects.

        close is also run when the object is garbage collected, and on
        exit when used as a context manager.

        """
        ...
    
    def __enter__(self) -> None:
        ...
    
    def __exit__(self, exc_type: Optional[Type[BaseException]], exc_value: Optional[BaseException], traceback: Optional[TracebackType]) -> None:
        ...
    
    async def __aenter__(self) -> BaseTestServer:
        ...
    
    async def __aexit__(self, exc_type: Optional[Type[BaseException]], exc_value: Optional[BaseException], traceback: Optional[TracebackType]) -> None:
        ...
    


class TestServer(BaseTestServer):
    def __init__(self, app: Application, *, scheme: Union[str, object] = ..., host: str = ..., port: Optional[int] = ..., **kwargs: Any):
        self.app = ...
    
    async def _make_runner(self, **kwargs: Any) -> BaseRunner:
        ...
    


class RawTestServer(BaseTestServer):
    def __init__(self, handler: _RequestHandler, *, scheme: Union[str, object] = ..., host: str = ..., port: Optional[int] = ..., **kwargs: Any) -> None:
        ...
    
    async def _make_runner(self, debug: bool = ..., **kwargs: Any) -> ServerRunner:
        ...
    


class TestClient:
    """
    A test client implementation.

    To write functional tests for aiohttp based servers.

    """
    __test__ = ...
    def __init__(self, server: BaseTestServer, *, cookie_jar: Optional[AbstractCookieJar] = ..., loop: Optional[asyncio.AbstractEventLoop] = ..., **kwargs: Any) -> None:
        ...
    
    async def start_server(self) -> None:
        ...
    
    @property
    def host(self) -> str:
        ...
    
    @property
    def port(self) -> Optional[int]:
        ...
    
    @property
    def server(self) -> BaseTestServer:
        ...
    
    @property
    def app(self) -> Application:
        ...
    
    @property
    def session(self) -> ClientSession:
        """An internal aiohttp.ClientSession.

        Unlike the methods on the TestClient, client session requests
        do not automatically include the host in the url queried, and
        will require an absolute path to the resource.

        """
        ...
    
    def make_url(self, path: str) -> URL:
        ...
    
    async def _request(self, method: str, path: str, **kwargs: Any) -> ClientResponse:
        ...
    
    def request(self, method: str, path: str, **kwargs: Any) -> _RequestContextManager:
        """Routes a request to tested http server.

        The interface is identical to aiohttp.ClientSession.request,
        except the loop kwarg is overridden by the instance used by the
        test server.

        """
        ...
    
    def get(self, path: str, **kwargs: Any) -> _RequestContextManager:
        """Perform an HTTP GET request."""
        ...
    
    def post(self, path: str, **kwargs: Any) -> _RequestContextManager:
        """Perform an HTTP POST request."""
        ...
    
    def options(self, path: str, **kwargs: Any) -> _RequestContextManager:
        """Perform an HTTP OPTIONS request."""
        ...
    
    def head(self, path: str, **kwargs: Any) -> _RequestContextManager:
        """Perform an HTTP HEAD request."""
        ...
    
    def put(self, path: str, **kwargs: Any) -> _RequestContextManager:
        """Perform an HTTP PUT request."""
        ...
    
    def patch(self, path: str, **kwargs: Any) -> _RequestContextManager:
        """Perform an HTTP PATCH request."""
        ...
    
    def delete(self, path: str, **kwargs: Any) -> _RequestContextManager:
        """Perform an HTTP PATCH request."""
        ...
    
    def ws_connect(self, path: str, **kwargs: Any) -> _WSRequestContextManager:
        """Initiate websocket connection.

        The api corresponds to aiohttp.ClientSession.ws_connect.

        """
        ...
    
    async def _ws_connect(self, path: str, **kwargs: Any) -> ClientWebSocketResponse:
        ...
    
    async def close(self) -> None:
        """Close all fixtures created by the test client.

        After that point, the TestClient is no longer usable.

        This is an idempotent function: running close multiple times
        will not have any additional effects.

        close is also run on exit when used as a(n) (asynchronous)
        context manager.

        """
        ...
    
    def __enter__(self) -> None:
        ...
    
    def __exit__(self, exc_type: Optional[Type[BaseException]], exc: Optional[BaseException], tb: Optional[TracebackType]) -> None:
        ...
    
    async def __aenter__(self) -> TestClient:
        ...
    
    async def __aexit__(self, exc_type: Optional[Type[BaseException]], exc: Optional[BaseException], tb: Optional[TracebackType]) -> None:
        ...
    


class AioHTTPTestCase(unittest.TestCase):
    """A base class to allow for unittest web applications using
    aiohttp.

    Provides the following:

    * self.client (aiohttp.test_utils.TestClient): an aiohttp test client.
    * self.loop (asyncio.BaseEventLoop): the event loop in which the
        application and server are running.
    * self.app (aiohttp.web.Application): the application returned by
        self.get_application()

    Note that the TestClient's methods are asynchronous: you have to
    execute function on the test client using asynchronous methods.
    """
    async def get_application(self) -> Application:
        """
        This method should be overridden
        to return the aiohttp.web.Application
        object to test.

        """
        ...
    
    def get_app(self) -> Application:
        """Obsolete method used to constructing web application.

        Use .get_application() coroutine instead

        """
        ...
    
    def setUp(self) -> None:
        self.loop = ...
        self.app = ...
        self.server = ...
        self.client = ...
    
    async def setUpAsync(self) -> None:
        ...
    
    def tearDown(self) -> None:
        ...
    
    async def tearDownAsync(self) -> None:
        ...
    
    async def get_server(self, app: Application) -> TestServer:
        """Return a TestServer instance."""
        ...
    
    async def get_client(self, server: TestServer) -> TestClient:
        """Return a TestClient instance."""
        ...
    


def unittest_run_loop(func: Any, *args: Any, **kwargs: Any) -> Any:
    """A decorator dedicated to use with asynchronous methods of an
    AioHTTPTestCase.

    Handles executing an asynchronous function, using
    the self.loop of the AioHTTPTestCase.
    """
    ...

_LOOP_FACTORY = Callable[[], asyncio.AbstractEventLoop]
@contextlib.contextmanager
def loop_context(loop_factory: _LOOP_FACTORY = ..., fast: bool = ...) -> Iterator[asyncio.AbstractEventLoop]:
    """A contextmanager that creates an event_loop, for test purposes.

    Handles the creation and cleanup of a test loop.
    """
    ...

def setup_test_loop(loop_factory: _LOOP_FACTORY = ...) -> asyncio.AbstractEventLoop:
    """Create and return an asyncio.BaseEventLoop
    instance.

    The caller should also call teardown_test_loop,
    once they are done with the loop.
    """
    ...

def teardown_test_loop(loop: asyncio.AbstractEventLoop, fast: bool = ...) -> None:
    """Teardown and cleanup an event_loop created
    by setup_test_loop.

    """
    ...

def _create_app_mock() -> mock.MagicMock:
    ...

def _create_transport(sslcontext: Optional[SSLContext] = ...) -> mock.Mock:
    ...

def make_mocked_request(method: str, path: str, headers: Any = ..., *, match_info: Any = ..., version: HttpVersion = ..., closing: bool = ..., app: Any = ..., writer: Any = ..., protocol: Any = ..., transport: Any = ..., payload: Any = ..., sslcontext: Optional[SSLContext] = ..., client_max_size: int = ..., loop: Any = ...) -> Any:
    """Creates mocked web.Request testing purposes.

    Useful in unit tests, when spinning full web server is overkill or
    specific conditions and errors are hard to trigger.

    """
    ...

def make_mocked_coro(return_value: Any = ..., raise_exception: Any = ...) -> Any:
    """Creates a coroutine mock."""
    ...

