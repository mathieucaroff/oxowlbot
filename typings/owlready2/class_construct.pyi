"""
This type stub file was generated by pyright.
"""

from owlready2.namespace import *
from owlready2.base import _universal_iri_2_abbrev
from typing import Any, Optional

_non_negative_integer = _universal_iri_2_abbrev["http://www.w3.org/2001/XMLSchema#nonNegativeInteger"]
def _deepcopy_construct(x):
  ...

class Construct(object):
  def __init__(self, ontology: Optional[Any] = ..., bnode: Optional[Any] = ...):
    self.ontology = ...
    self.storid = ...
  
  def _set_ontology_copy_if_needed(self, ontology, l):
    ...
  
  def _set_ontology(self, ontology):
    self.ontology = ...
  
  def destroy(self):
    ...
  
  def _destroy_triples(self, ontology):
    ...
  
  def _create_triples(self, ontology):
    ...
  


class ClassConstruct(Construct):
  def __and__(a, b):
    ...
  
  def __or__(a, b):
    ...
  
  def __invert__(a):
    ...
  
  def subclasses(self, only_loaded: bool = ..., include_equivalent: bool = ...):
    ...
  
  def ancestors(Class, include_self: bool = ..., include_constructs: bool = ...):
    ...
  


class Not(ClassConstruct):
  is_a = ...
  def __init__(self, Class, ontology: Optional[Any] = ..., bnode: Optional[Any] = ...):
    ...
  
  def __deepcopy__(self):
    ...
  
  def __eq__(self, other):
    ...
  
  def __hash__(self):
    ...
  
  def __repr__(self):
    ...
  
  def __getattr__(self, attr):
    ...
  
  def destroy(self):
    ...
  
  def _set_ontology(self, ontology):
    ...
  
  def __setattr__(self, attr, value):
    ...
  
  def _create_triples(self, ontology):
    ...
  
  def _satisfied_by(self, x):
    ...
  


class Inverse(ClassConstruct):
  is_a = ...
  def __new__(Class, Property, ontology: Optional[Any] = ..., bnode: Optional[Any] = ..., simplify: bool = ...):
    ...
  
  def __eq__(self, other):
    ...
  
  def __hash__(self):
    ...
  
  def __init__(self, Property, ontology: Optional[Any] = ..., bnode: Optional[Any] = ..., simplify: bool = ...):
    ...
  
  def __deepcopy__(self):
    ...
  
  def __repr__(self):
    ...
  
  def __setattr__(self, attr, value):
    ...
  
  def _create_triples(self, ontology):
    ...
  
  def some(self, value):
    ...
  
  def only(self, value):
    ...
  
  def value(self, value):
    ...
  
  def exactly(self, nb, value: Optional[Any] = ...):
    ...
  
  def min(self, nb, value: Optional[Any] = ...):
    ...
  
  def max(self, nb, value: Optional[Any] = ...):
    ...
  


class LogicalClassConstruct(ClassConstruct):
  def __init__(self, Classes, ontology: Optional[Any] = ..., bnode: Optional[Any] = ...):
    ...
  
  def __deepcopy__(self):
    ...
  
  def __eq__(self, other):
    ...
  
  def __hash__(self):
    ...
  
  def __rshift__(Domain, Range):
    ...
  
  def _set_ontology(self, ontology):
    ...
  
  def __getattr__(self, attr):
    ...
  
  def _invalidate_list(self):
    ...
  
  def _callback(self, old):
    ...
  
  def _destroy_triples(self, ontology):
    ...
  
  def _create_triples(self, ontology):
    ...
  
  def __repr__(self):
    ...
  


class Or(LogicalClassConstruct):
  _owl_op = ...
  _char = ...
  is_a = ...
  def __or__(self, b):
    ...
  
  def _satisfied_by(self, x):
    ...
  


class And(LogicalClassConstruct):
  _owl_op = ...
  _char = ...
  def __and__(self, b):
    ...
  
  def _satisfied_by(self, x):
    ...
  
  def get_is_a(self):
    ...
  
  is_a = ...


_qualified_2_non_qualified = { EXACTLY: owl_cardinality,MIN: owl_min_cardinality,MAX: owl_max_cardinality }
_restriction_type_2_label = { SOME: "some",ONLY: "only",VALUE: "value",HAS_SELF: "has_self",EXACTLY: "exactly",MIN: "min",MAX: "max" }
class Restriction(ClassConstruct):
  is_a = ...
  def __init__(self, Property, type, cardinality: Optional[Any] = ..., value: Optional[Any] = ..., ontology: Optional[Any] = ..., bnode: Optional[Any] = ...):
    ...
  
  def __deepcopy__(self):
    ...
  
  def __eq__(self, other):
    ...
  
  def __hash__(self):
    ...
  
  def __repr__(self):
    ...
  
  def _set_ontology(self, ontology):
    ...
  
  def _create_triples(self, ontology):
    ...
  
  def __getattr__(self, attr):
    ...
  
  def __setattr__(self, attr, v):
    ...
  
  def _satisfied_by(self, x):
    ...
  


class OneOf(ClassConstruct):
  is_a = ...
  def __init__(self, instances, ontology: Optional[Any] = ..., bnode: Optional[Any] = ...):
    ...
  
  def __deepcopy__(self):
    ...
  
  def __eq__(self, other):
    ...
  
  def __hash__(self):
    ...
  
  def __getattr__(self, attr):
    ...
  
  def _invalidate_list(self):
    ...
  
  def _callback(self, old):
    ...
  
  def _destroy_triples(self, ontology):
    ...
  
  def _create_triples(self, ontology):
    ...
  
  def _satisfied_by(self, x):
    ...
  
  def __repr__(self):
    ...
  


class PropertyChain(Construct):
  def __init__(self, Properties, ontology: Optional[Any] = ...):
    ...
  
  def _set_ontology(self, ontology):
    ...
  
  def __getattr__(self, attr):
    ...
  
  def _invalidate_list(self):
    ...
  
  def _callback(self, old):
    ...
  
  def _destroy_triples(self, ontology):
    ...
  
  def _create_triples(self, ontology):
    ...
  
  def __repr__(self):
    ...
  


_PY_FACETS = {  }
_RDFS_FACETS = {  }
def _facets(py_name, rdfs_name, value_datatype, value_datatype_abbrev):
  ...

class ConstrainedDatatype(ClassConstruct):
  def __init__(self, base_datatype, ontology: Optional[Any] = ..., bnode: Optional[Any] = ..., list_bnode: Optional[Any] = ..., **kargs):
    ...
  
  def __deepcopy__(self):
    ...
  
  def __setattr__(self, attr, value):
    ...
  
  def __repr__(self):
    ...
  
  def _destroy_triples(self, ontology):
    ...
  
  def _create_triples(self, ontology):
    ...
  


