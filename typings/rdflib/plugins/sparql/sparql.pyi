"""
This type stub file was generated by pyright.
"""

from rdflib.plugins.sparql.compat import Mapping, MutableMapping
from typing import Any, Optional

class SPARQLError(Exception):
    def __init__(self, msg: Optional[Any] = ...):
        ...
    


class NotBoundError(SPARQLError):
    def __init__(self, msg: Optional[Any] = ...):
        ...
    


class AlreadyBound(SPARQLError):
    """Raised when trying to bind a variable that is already bound!"""
    def __init__(self):
        ...
    


class SPARQLTypeError(SPARQLError):
    def __init__(self, msg):
        ...
    


class Bindings(MutableMapping):
    """

    A single level of a stack of variable-value bindings.
    Each dict keeps a reference to the dict below it,
    any failed lookup is propegated back

    In python 3.3 this could be a collections.ChainMap
    """
    def __init__(self, outer: Optional[Any] = ..., d=...):
        self.outer = ...
    
    def __getitem__(self, key):
        ...
    
    def __contains__(self, key):
        ...
    
    def __setitem__(self, key, value):
        ...
    
    def __delitem__(self, key):
        ...
    
    def __len__(self):
        ...
    
    def __iter__(self):
        ...
    
    def __str__(self):
        ...
    
    def __repr__(self):
        ...
    


class FrozenDict(Mapping):
    """
    An immutable hashable dict

    Taken from http://stackoverflow.com/a/2704866/81121

    """
    def __init__(self, *args, **kwargs):
        ...
    
    def __iter__(self):
        ...
    
    def __len__(self):
        ...
    
    def __getitem__(self, key):
        ...
    
    def __hash__(self):
        ...
    
    def project(self, vars):
        ...
    
    def disjointDomain(self, other):
        ...
    
    def compatible(self, other):
        ...
    
    def merge(self, other):
        ...
    
    def __str__(self):
        ...
    
    def __repr__(self):
        ...
    


class FrozenBindings(FrozenDict):
    def __init__(self, ctx, *args, **kwargs):
        self.ctx = ...
    
    def __getitem__(self, key):
        ...
    
    def project(self, vars):
        ...
    
    def merge(self, other):
        ...
    
    def _now(self):
        ...
    
    def _bnodes(self):
        ...
    
    def _prologue(self):
        ...
    
    prologue = ...
    bnodes = ...
    now = ...
    def forget(self, before, _except: Optional[Any] = ...):
        """
        return a frozen dict only of bindings made in self
        since before
        """
        ...
    
    def remember(self, these):
        """
        return a frozen dict only of bindings in these
        """
        ...
    


class QueryContext(object):
    """
    Query context - passed along when evaluating the query
    """
    def __init__(self, graph: Optional[Any] = ..., bindings: Optional[Any] = ..., initBindings: Optional[Any] = ...):
        self.initBindings = ...
        self.bindings = ...
        self.prologue = ...
        self.now = ...
        self.bnodes = ...
    
    def clone(self, bindings: Optional[Any] = ...):
        ...
    
    def _get_dataset(self):
        ...
    
    dataset = ...
    def load(self, source, default: bool = ..., **kwargs):
        ...
    
    def __getitem__(self, key):
        ...
    
    def get(self, key, default: Optional[Any] = ...):
        ...
    
    def solution(self, vars: Optional[Any] = ...):
        """
        Return a static copy of the current variable bindings as dict
        """
        ...
    
    def __setitem__(self, key, value):
        ...
    
    def pushGraph(self, graph):
        ...
    
    def push(self):
        ...
    
    def clean(self):
        ...
    
    def thaw(self, frozenbindings):
        """
        Create a new read/write query context from the given solution
        """
        ...
    


class Prologue(object):
    """
    A class for holding prefixing bindings and base URI information
    """
    def __init__(self):
        self.base = ...
        self.namespace_manager = ...
    
    def resolvePName(self, prefix, localname):
        ...
    
    def bind(self, prefix, uri):
        ...
    
    def absolutize(self, iri):
        """
        Apply BASE / PREFIXes to URIs
        (and to datatypes in Literals)

        TODO: Move resolving URIs to pre-processing
        """
        ...
    


class Query(object):
    """
    A parsed and translated query
    """
    def __init__(self, prologue, algebra):
        self.prologue = ...
        self.algebra = ...
    


