"""
This type stub file was generated by pyright.
"""

from typing import Any, Optional

PAD = '<PAD>'
PAD_ID = 0
UNK = '<UNK>'
UNK_ID = 1
EMPTY = '<EMPTY>'
EMPTY_ID = 2
ROOT = '<ROOT>'
ROOT_ID = 3
VOCAB_PREFIX = [PAD, UNK, EMPTY, ROOT]
class BaseVocab:
    """ A base class for common vocabulary operations. Each subclass should at least 
    implement its own build_vocab() function."""
    def __init__(self, data: Optional[Any] = ..., lang=..., idx=..., cutoff=..., lower: bool = ...):
        self.data = ...
        self.lang = ...
        self.idx = ...
        self.cutoff = ...
        self.lower = ...
        self.state_attrs = ...
    
    def build_vocab(self):
        ...
    
    def state_dict(self):
        """ Returns a dictionary containing all states that are necessary to recover
        this vocab. Useful for serialization."""
        ...
    
    @classmethod
    def load_state_dict(cls, state_dict):
        """ Returns a new Vocab instance constructed from a state dict. """
        ...
    
    def normalize_unit(self, unit):
        ...
    
    def unit2id(self, unit):
        ...
    
    def id2unit(self, id):
        ...
    
    def map(self, units):
        ...
    
    def unmap(self, ids):
        ...
    
    def __len__(self):
        ...
    
    def __getitem__(self, key):
        ...
    
    def __contains__(self, key):
        ...
    
    @property
    def size(self):
        ...
    


class CompositeVocab(BaseVocab):
    ''' Vocabulary class that handles parsing and printing composite values such as
    compositional XPOS and universal morphological features (UFeats).

    Two key options are `keyed` and `sep`. `sep` specifies the separator used between
    different parts of the composite values, which is `|` for UFeats, for example.
    If `keyed` is `True`, then the incoming value is treated similarly to UFeats, where
    each part is a key/value pair separated by an equal sign (`=`). There are no inherit
    order to the keys, and we sort them alphabetically for serialization and deserialization.
    Whenever a part is absent, its internal value is a special `<EMPTY>` symbol that will
    be treated accordingly when generating the output. If `keyed` is `False`, then the parts
    are treated as positioned values, and `<EMPTY>` is used to pad parts at the end when the
    incoming value is not long enough.'''
    def __init__(self, data: Optional[Any] = ..., lang=..., idx=..., sep=..., keyed: bool = ...):
        self.sep = ...
        self.keyed = ...
    
    def unit2parts(self, unit):
        ...
    
    def unit2id(self, unit):
        ...
    
    def id2unit(self, id):
        ...
    
    def build_vocab(self):
        ...
    
    def lens(self):
        ...
    


class BaseMultiVocab:
    """ A convenient vocab container that can store multiple BaseVocab instances, and support 
    safe serialization of all instances via state dicts. Each subclass of this base class 
    should implement the load_state_dict() function to specify how a saved state dict 
    should be loaded back."""
    def __init__(self, vocab_dict: Optional[Any] = ...):
        ...
    
    def __setitem__(self, key, item):
        ...
    
    def __getitem__(self, key):
        ...
    
    def state_dict(self):
        """ Build a state dict by iteratively calling state_dict() of all vocabs. """
        ...
    
    @classmethod
    def load_state_dict(cls, state_dict):
        """ Construct a MultiVocab by reading from a state dict."""
        ...
    


